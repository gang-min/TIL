# 해시테이블 (hashtable)

## 1. 해시 함수 (hash function)란?

- 해시테이블을 알기전에 해시 함수에 대해서 먼저 알아야 한다.

- 해시 함수란 임의의 길이의 데이터(Plain Text)를 `고정된 길이의 데이터로 매핑`하는 함수이다.

> 자료구조를 배우는 이유는 원하는 값을 최대한 효율적으로 찾을 수 있게 하기 위해서 여러가지 저장구조를 배우는 것인데, 데이터를 최대한 빠르게 찾기 위해서는 저장하는 위치도 잘 생각해서 저장해야 한다. 해시 함수의 정의는 key를 "고정된 길이"의 해시로 변경해주는 역할을 한다. 이 과정을 "hashing"이라고 한다. key를 해시함수라는 함수에 input으로 넣어서 output으로 나오는 것이 hash라고 생각하면 되고, 이 hash가 저장위치가 된다고 생각하면 된다. 결국 해시 함수는 key로 해시를 만들어내는 함수이다.

![해시함수](/image/해쉬함수.png)

- 해시 함수의 특성

  - 압축성 : 다양한 가변 길이의 입력에 대해 고정된 크기의 결과값을 반환하는 성질

  - 효율성 : 어떤 입력 값에 대해서도 많은 자원과 시간이 소요되지 않고 처리되는 성질

  - `저항성` : 결과값을 바탕으로 입력 값을 찾는 것이 불가능한 성질

- 해시 함수의 가장 기본적인 성질

  - 두 해시 값(Hashed Text)이 다르면 원래의 데이터의 값(Plain Text)도 다르다.

  - 하지만, 같은 해시값을 가지고 있더라도 원래의 데이터가 꼭 같은 것은 아니다.

## 2. 해시테이블이란?

- 해시테이블도 딕셔너리와 동일하게 key와 value 형태의 값을 저장하는 자료구조이다.

- 딕셔너리(Object)도 key-value 형태인데 딕셔너리의 key값도 자바스크립트 내부적으로 hashed된 값으로 저장되어 있다. 그래서 그 key값에 매핑되는 hash값을 찾아서 배열내에서 빠르게 value를 찾을 수 있다.

- 자바스크립트 내부적으로 동작하는 것 말고 그런것들을 우리가 순수 구현을 하는것이 해시테이블이다.

- 해시 테이블은 어떤 특정한 값을 받으면 그 값을 `해시 함수`에 통과시켜 나온 `인덱스`에 저장하는 자료구조이다.

- 즉, 해시테이블은 해시 함수를 사용하여 키를 해시 값으로 매핑하고, 이 해시값을 index로 삼아 value를 저장하는 자료구조이다.

  ![해시테이블](/image/해시테이블.png)

- `해시 함수를 사용`하여 평균 O(1) 시간 복잡도로 특정 값을 신속하게 찾는 자료구조이다.

## 3. 해시테이블의 장점과 단점

- 장점

  - 해시테이블은 key-value가 1:1로 매핑되어 있기 때문에 삽입, 삭제, 탐색의 과정에서도` 모두 평균적으로 O(1)의 시간 복잡도`를 가지고 있다. 따라서 매우 빠르다.

- 단점

  - `해시 충돌이 발생`(개방 주소법, 체이닝 과 같은 기법으로 해결해 줘야 한다.)

  - 순서/관계가 있는 배열에는 어울리지 않는다.

  - 공간 효율성이 떨어진다. 데이터가 저장되기 전에 저장공간을 미리 만들어놔야 한다. 공간을 만들었지만 공간에 채워지지 않는 경우가 발생한다.

  - 해시 함수의 의존도가 높다. 해시 함수가 복잡하다면 해쉬를 만들어 내는데 오래 걸릴 것이다.

  > 키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블을 Direct-address table이라고 한다. Direct-address table의 장점은 키의 개수와 테이블의 크기가 같기 때문에 해시 충돌 문제가 발생하지 않는다는 것이다. 하지만 실제 사용하는 키는 명개 되지 않을 경우에는 전체 키의 갯수만큼의 테이블 크기를 유지하는 것은 메모리 낭비이다. 그래서 실제 키 개수보다 적은 해시테이블을 운용한다. 그렇기에 해시 충돌이 발생할수 밖에 없고, 해시 충돌을 해결하기 위해 다양한 방법들이 고안되었다.

  ![해시테이블](/image/해시테이블2.png)

## 4. 해쉬 충돌 (Collision)

- 만약 A,B 두가지 key가 있다고 하자. A와 B를 해시 함수로 해시 값을 얻었는데 해시 값이 2로 똑같이 나왔다. 이런 현상을 해시 충돌이라고 한다.

- 해시 함수로 해시를 만드는 과정에서 서로 다른 key가 같은 해시로 변경되면 같은 공간에 2개의 value가 저장되므로 key-value가 1:1로 매핑되어야 하는 해시 테이블의 특성에 위배된다. 해시 충돌은 필연적으로 나타날 수 밖에 없다.

## 5. 해시 충돌 해결 방법

- 5-1. 해시 함수 변경(해시 함수 매핑 개선)

  - 특정 값에 치우치지 않고 해시값을 고르게 만들어내는 해시함수가 좋은 해시함수라고 할 수 있다.

  - `division method`  
     : 가장 기본적인 해시 함수이다. 숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 변환한다. 간단하면서도 빠른 연산이 가능한 것이 장점이다.
    해시의 중복을 방지하기 위해 테이블의 크기 m은 소수로 지정해서 사용하는것이 좋다. 하지만 남는 공간이 발생해 메모리상으로 비효율적이다.

  - `multiplication method`

    : 숫자 키 k, A는 0<A<1 사이의 실수 일때 h(k) = (ka mod 1)\*m 으로 계산한다.
    2진수 연산에 최적화된 컴퓨터구조를 고려한 해시함수이다.

  - `univeral hasing`

    : 여러개의 해시함수를 만들고, 이 해사함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.
    서로 다른 해시함수가 서로 다른 해시값을 만들어내기 때문에 같은 공간에 매핑할 확률을 줄이는 것이 목적이다.

- 5-1. 자료구조 확장

  - `Open Addressing Method (선형 조사법, 이중해시)`

  - `Close Addressing Method (체이닝)`

## 6. 해시 테이블 구현

- ### 6. 해시 테이블 구현 (1)

  - Element() 생성자 함수, HashTable() 생성자 함수, hashCode() 해시 함수 구현

    ![해시테이블](/image/해시테이블3.png)

- ### 6. 해시 테이블 구현 (2)

  - put() 메서드, get() 메서드, remove() 메서드 구현

    ![해시테이블](/image/해시테이블4.png)

- ### 6. 해시 테이블 구현 (3)

  - clear() 메서드, size() 메서드, getBuffer() 메서드, print() 메서드 구현

    ![해시테이블](/image/해시테이블5.png)
