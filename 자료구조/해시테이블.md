# 해시테이블 (hashtable)

## 1. 해시 함수 (hash function)란?

- 해시테이블을 알기전에 해시 함수에 대해서 먼저 알아야 한다.

- 해시 함수란 임의의 길이의 데이터(Plain Text)를 `고정된 길이의 데이터로 매핑`하는 함수이다.

  ![해시함수](/image/해시함수2.png)

  ![해시함수](/image/해시함수3.png)

> 자료구조를 배우는 이유는 원하는 값을 최대한 효율적으로 찾을 수 있게 하기 위해서 여러가지 저장구조를 배우는 것인데, 데이터를 최대한 빠르게 찾기 위해서는 저장하는 위치도 잘 생각해서 저장해야 한다. 해시 함수의 정의는 key를 "고정된 길이"의 해시로 변경해주는 역할을 한다. 이 과정을 "hashing"이라고 한다. key를 해시함수라는 함수에 input으로 넣어서 output으로 나오는 것이 hash라고 생각하면 되고, 이 hash가 저장위치가 된다고 생각하면 된다. 결국 해시 함수는 key로 해시를 만들어내는 함수이다.

![해시함수](/image/해쉬함수.png)

- 해시 함수의 특성

  - 압축성 : 다양한 가변 길이의 입력에 대해 고정된 크기의 결과값을 반환하는 성질

  - 효율성 : 어떤 입력 값에 대해서도 많은 자원과 시간이 소요되지 않고 처리되는 성질

  - `저항성` : 결과값을 바탕으로 입력 값을 찾는 것이 불가능한 성질

- 해시 함수의 가장 기본적인 성질

  - 두 해시 값(Hashed Text)이 다르면 원래의 데이터의 값(Plain Text)도 다르다.

  - 하지만, 같은 해시값을 가지고 있더라도 원래의 데이터가 꼭 같은 것은 아니다.

## 2. 해시테이블이란?

- 해시테이블도 딕셔너리와 동일하게 key와 value 형태의 값을 저장하는 자료구조이다.

- 딕셔너리(Object)도 key-value 형태인데 딕셔너리의 key값도 자바스크립트 내부적으로 hashed된 값으로 저장되어 있다. 그래서 그 key값에 매핑되는 hash값을 찾아서 배열내에서 빠르게 value를 찾을 수 있다.

- 자바스크립트 내부적으로 동작하는 것 말고 그런것들을 우리가 순수 구현을 하는것이 해시테이블이다.

- 해시 테이블은 어떤 특정한 값을 받으면 그 값을 `해시 함수`에 통과시켜 나온 `인덱스`에 저장하는 자료구조이다.

- 즉, 해시테이블은 해시 함수를 사용하여 키를 해시 값으로 매핑하고, 이 해시값을 index로 삼아 value를 저장하는 자료구조이다.

  ![해시테이블](/image/해시테이블.png)

- `해시 함수를 사용`하여 평균 O(1) 시간 복잡도로 특정 값을 신속하게 찾는 자료구조이다.

> 해시 충돌이 발생할 가능성이 있음에도 불구하고 해시 테이블을 사용하는 이유는 적은 리소스로 많은 데이터를 효과적으로 관리하기 위함이다.

## 3. 해시의 목적

- 해시 테이블

  - 해시 테이블은 데이터의 해시 값을 테이블 내 주소로 이용하는 탐색 알고리즘으로, 잘 구현하면 이진 탐색보다 빠르게 처리할 수 있다.

- 암호화

  - 암호화에서 해시는 자주 등장한다. 어떤 값들을 해시로 변환하면, 기존의 값을 알아볼 수 없게 만든다. 이것 자체가 암호화에 매우 유용하며, 이런 해시의 특성을 활용한 대표적인 암호화 알고리즘이 SHA(Secure Hash Algorithm)이다.

- 데이터 축약

  - 길이가 다른 데이터를 일정한 길이로 축약시킬 수 있다. 방대한 양의 데이터를 해시로 줄일 수 있으며, 데이터 비교에 있어서도 축약한 것을 비교하는 것이 원본 데이터를 비교하는 것보다 빠른 성능을 보일 수 있다. 단, 데이터가 다름에도 해시 값이 같은 경우가 발생할 수 있이 떄문에, 충돌 가능성을 고려해야 한다.

## 4. 해시테이블의 장점과 단점

- 장점

  - 해시테이블은 key-value가 1:1로 매핑되어 있기 때문에 삽입, 삭제, 탐색의 과정에서도` 모두 평균적으로 O(1)의 시간 복잡도`를 가지고 있다. 따라서 매우 빠르다.

- 단점

  - `해시 충돌이 발생`(개방 주소법, 체이닝 과 같은 기법으로 해결해 줘야 한다.)

  - 순서/관계가 있는 배열에는 어울리지 않는다.

  - 공간 효율성이 떨어진다. 데이터가 저장되기 전에 저장공간을 미리 만들어놔야 한다. 공간을 만들었지만 공간에 채워지지 않는 경우가 발생한다.

  - 해시 함수의 의존도가 높다. 해시 함수가 복잡하다면 해쉬를 만들어 내는데 오래 걸릴 것이다.

  > 키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블을 Direct-address table이라고 한다. Direct-address table의 장점은 키의 개수와 테이블의 크기가 같기 때문에 해시 충돌 문제가 발생하지 않는다는 것이다. 하지만 실제 사용하는 키는 명개 되지 않을 경우에는 전체 키의 갯수만큼의 테이블 크기를 유지하는 것은 메모리 낭비이다. 그래서 실제 키 개수보다 적은 해시테이블을 운용한다. 그렇기에 해시 충돌이 발생할수 밖에 없고, 해시 충돌을 해결하기 위해 다양한 방법들이 고안되었다.

  > 데이터가 저장되는 곳을 버킷(Bucket) 또는 슬롯(Slot)이라 한다.

  ![해시테이블](/image/해시테이블2.png)

## 5. 해시 테이블 구현

- [해시 테이블 구현 코드](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94.html)

- ### 5-1. 해시 테이블 구현 (1)

  - Element() 생성자 함수, HashTable() 생성자 함수, hashCode() 해시 함수 구현

    ![해시테이블](/image/해시테이블3.png)

- ### 5-1. 해시 테이블 구현 (2)

  - put() 메서드, get() 메서드, remove() 메서드 구현

    ![해시테이블](/image/해시테이블4.png)

- ### 5-1. 해시 테이블 구현 (3)

  - clear() 메서드, size() 메서드, getBuffer() 메서드, print() 메서드 구현

    ![해시테이블](/image/해시테이블5.png)

## 6. 해쉬 충돌 (Collision)

- 만약 A,B 두가지 key가 있다고 하자. A와 B를 해시 함수로 해시 값을 얻었는데 해시 값이 2로 똑같이 나왔다. 이런 현상을 해시 충돌이라고 한다.

- 해시 함수로 해시를 만드는 과정에서 서로 다른 key가 같은 해시로 변경되면 같은 공간에 2개의 value가 저장되므로 key-value가 1:1로 매핑되어야 하는 해시 테이블의 특성에 위배된다. 해시 충돌은 필연적으로 나타날 수 밖에 없다.

## 7. 해시 충돌 해결 방법

- 7-1. 해시 함수 변경(해시 함수 매핑 개선)

  - 특정 값에 치우치지 않고 해시값을 고르게 만들어내는 해시함수가 좋은 해시함수라고 할 수 있다.

  - `loselose method`  
    : 키를 구성하는 문자의 아스키 값을 단순히 더한것이다.

  - `division method`  
     : 가장 기본적인 해시 함수이다. 숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 변환한다. 간단하면서도 빠른 연산이 가능한 것이 장점이다.
    해시의 중복을 방지하기 위해 테이블의 크기 m은 소수로 지정해서 사용하는것이 좋다. 하지만 남는 공간이 발생해 메모리상으로 비효율적이다.

  - `djb2 method`

  - `multiplication method`

    : 숫자 키 k, A는 0<A<1 사이의 실수 일때 h(k) = (ka mod 1)\*m 으로 계산한다.
    2진수 연산에 최적화된 컴퓨터구조를 고려한 해시함수이다.

  - `univeral hasing`

    : 여러개의 해시함수를 만들고, 이 해사함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.
    서로 다른 해시함수가 서로 다른 해시값을 만들어내기 때문에 같은 공간에 매핑할 확률을 줄이는 것이 목적이다.

- 7-1. 자료구조 확장

  - `Open Addressing Method (선형 조사법, 제곱탐색, 이중해시)`

    - Open Addressing Method (개방 주소법)의 장점

      1. 체이닝처럼 포인터가 필요없고, 저장한 메모리 외 추가적인 저장공간도 필요없다.

      2. 삽입, 삭제시 오버헤드가 적다.

      3. 저장할 데이터가 적을 때 유리하다.

  - `Close Addressing Method (체이닝)`

    - 체이닝의 장점

      1. 연결 리스트만 사용하면 된다. 즉, 복잡한 계산식을 사용할 필요가 개방주소법에 비해 적다.

      2. 해시테이블이 채워질수록, Lookup 성능저하가 Linear하게 발생한다.

## 8. 충돌 해결

- 8-1. 해시 함수 변경 케이스

  - loselose Methode (기존) -> djb2 method(변경)

  - [해시 함수 변경 구현 코드](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98djb2.html)

  - 아래는 충돌이 난 경우이다.

    ![해시충돌](/image/해시충돌.png)

  - Ana와 Donnie의 해시값이 같고, Sue와 Jamie의 해시값이 같기 떄문에 해시테이블은 Ana, Sue, Paul만 put() 되었다.

    ![해시충돌](/image/해시충돌2.png)

  - 해시함수를 변경해줌으로서 해결할 수 있다.

    ![해시충돌](/image/해시충돌3.png)

- 8-2. 자료구조 확장 케이스

  - 8-2-1. Open Addressing Method 중에서 `선형 조사법 해시 테이블 (Linear probing Hash Table)`로 해시 충돌을 해결할 수 있다.

    - Hash 충돌이 발생했을 때, `그 다음(옆에) 주소를 확인하고 비어 있다면 그 자리에 대신 저장`하는 해시테이블 기반 자료구조이다.

      ![선형조사법](/image/선형조사법.png)

    - `선형 조사법 해시테이블 구현하기`

      - [선형 조사법 구현 코드](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%84%A0%ED%98%95%EC%A1%B0%EC%82%AC%EB%B2%95.html)

      - Element() 생성자 함수, LinearHashTable() 생성자 함수, hashCode() 해시함수, clear() 메서드, size() 메서드, getBuffer() 메서드, print() 메서드 구현

        ![선형조사법](/image/선형조사법2.png)

      - put() 메서드 추가 , 기존 해시테이블과 선형 조사법 해시테이블의 put() 메서드는 차이가 있다.

      - hash값에 이미 저장되어있다면 다음 번의 index(hash값 + 1 / HASH_SIZE)로 들어가게되는데 만약 해시 사이즈가 가득 차있다면 어느곳에도 들어가지 못한다.

        ![선형조사법](/image/선형조사법3.png)

      - get() 메서드 추가 , 기존 해시테이블과 선형 조사법 해시테이블의 get() 메서드는 차이가 있다.

      - get은 해당 index가 값이 있다면 그 index의 key값과 매개변수 key가 맞는지 체크하고 만약 맞다면 그 key값의 value를 반환한다.

        ![선형조사법](/image/선형조사법4.png)

      - remove() 메서드 추가 , 기존 해시테이블과 선형 조사법 해시테이블의 remove() 메서드는 차이가 있다.

        ![선형조사법](/image/선형조사법5.png)

  - 8-2-2. Close Addressing Method `(Chaining Hash Table)`로 해시 충돌을 해결할 수 있다.

    - Hash 충돌이 발생했을 때, `별도의 자료구조인 연결 리스트를 병합 사용`하여 Hash 충돌을 해결한 해시테이블 기반 자료 구조이다.

      ![체이닝](/image/체이닝2.png)

    - 즉, 충돌이 발생했을 때 이를 동일한버킷(Bucket)에 저장하는데 이를 연결리스트 형태로 저장하는 방법을 말한다.

      ![체이닝](/image/체이닝.png)

    - `Chaining Hash Table 구현하기`

      - [Chaining Hash Table 구현 코드](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%B2%B4%EC%9D%B4%EB%8B%9D.html)

      - 기본적으로 LinkedList가 있어야 한다.

        ![체이닝-연결리스트](/image/체이닝-연결리스트.png)

        ![체이닝-연결리스트](/image/체이닝-연결리스트2.png)

      - Element() 생성자 함수, ChainingHashTable() 생성자 함수, hashCode() : 해시 함수, clear() 메서드, size() 메서드 구현

        ![체이닝](/image/체이닝3.png)

      - put() 메서드 구현, hash값의 index가 비어있다면 연결리스트를 만들어주고, 만약 hash값에 value가 있다면 연결리스트로 연결을 시켜준다.

        ![체이닝](/image/체이닝4.png)

      - getBuffer() 메서드, print() 메서드 구현

        ![체이닝](/image/체이닝5.png)

      - get() 메서드 구현

        ![체이닝](/image/체이닝6.png)

      - remove() 메서드 구현

        ![체이닝](/image/체이닝7.png)
