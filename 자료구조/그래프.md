# 그래프 (Graph)

## 1. 그래프란?

- `정점(=node)`과 노드와 노드간을 연결하는 `간선`으로 구성되어 `네트워크 구조`를 추상화한 비선형 자료 구조이다.

- 즉, 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조이다.

  - ex) 지도, 지하철 노선도의 최단 경로, 전기 회로의 소자들, 도로(교차점과 일방 통행길), 선수 과목 등..

- 그래프는 여러 개의 고립된 부분 그래프(Isolated Subgraphs)로 구성 될 수 있다. 즉, 다양한 그래프 종류를 혼합하여 표현 가능하다.

- 그래프의 특징

  - 그래프는 `네트워크 모델`이다.

  - 노드간에 2개 이상의 경로도 가능하다.

  - self-loop 뿐 아니라 loop/circuit 모두 가능하다.

  - 루트 노드라는 개념이 없다.

  - 부모-자식 관계라는 개념이 없다.

  - `순회는 DFS나 BFS로 이루어진다.`

  - 그래프는 순환(Cyclic) 혹은 비순환(Acyclic) 구조를 이룬다.

  - 그래프는 방향성이 있는 그래프와 방향성이 없는 무방향 그래프가 있다.

  - 간선의 유무는 그래프에 따라 다르다.

- `그래프와 트리의 차이`

  ![그래프](/image/그래프.png)

> 참고  
> 오일러 경로(Eulerian tour)
>
> - 그래프에 존재하는 모든 간선(edge)을 한 번만 통과하면서 처음 정점(vertex)으로 되돌아오는 경로를 말한다.
> - 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.

- 그래프의 종류

  - 방향 그래프(Directed Graph) : 간선에 특정 방향이 존재하는 그래프(A -> B로 표현, `A에서 B로만 이동 가능`)

  - 무방향 그래프(Undirected Graph) : 간선에 특정 방향이 존재하지 않는 그래프 (A - B로 표현, `양방향 이동 가능`)

  - 가중치 그래프(Weighted Graph) : 간선에 비용이나 가중치가 할당된 그래프

  - 연결 그래프(Connected Graph) : 무방향 그래프에 있는 모든 정점쌍에 대해 항상 경로가 존재하는 그래프

  - 비연결 그래프(DisConnected Graph) : 무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 그래프

  - 순환 그래프(Cyclic Graph) : 단순 경로의 시작 정점과 종료 정점이 동일하여 순환 지점이 존재하는 그래프

  - 비순환 그래프(Acyclic Graph) : 순환 지점이 존재하지 않는 그래프

    - ex) 트리(DAG, Directed Acyclic Graph)

  - 완전 그래프(Complete Graph) : 그래프에 속해 있는 모든 정점이 서로연결되어 있는 그래프

    ![그래프](/image/그래프2.png)

    ![그래프](/image/그래프3.png)

## 2. 그래프와 관련된 용어

- 정점(vertex) : 위치라는 개념. (node 라고도 부른다.)

- 간선(edge) : 위치 간의 관계. 즉, 노드를 연결하는 선 (link, branch 라고도 부른다.)

- 인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점.

- 정점의 차수(degree) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수.

- 진입 차수(in-degree) : 방향 그래프에서 외부에서 오는 간선의 수. (내차수 라고도 부른다.)

- 진출 차수(out-degree) : 방향 그래프에서 외부로 향하는 간선의 수. (외차수 라고도 부른다.)

  > 방향 그래프에 있는 정점의 진입 차수 또는 진출 차수의 합 = 방향 그래프의 간선의 수. (내차수 + 외차수)

- 경로 길이(path length) : 경로를 구성하는데 사용된 간선의 수.

- 단순 경로(simple path) : 경로 중에서 반복되는 정점이 없는 경우.

- 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우.

## 3. 그래프 표현 방법

- 그래프를 표현하는 방법은 크게 두가지가 있다.

- ### 3-1. 인접 리스트(Adjacency List) : 정점에 연결된 다른 정점을 `리스트(배열, 연결리스트, 딕셔너리, 해시 등...)`로 표현

  ![그래프](/image/그래프4.png)

- ### 3-2. 인접 행렬(Adjacency Matrix) : 정점에 연결된 다른 정점을 정점x정점 크기의 `매트릭스`로 표현

  ![그래프](/image/그래프5.png)

## 4. 그래프 구현

- 딕셔너리 객체를 이용해서 인접리스트로 `방향` 그래프를 구현해 볼 것이다.

  ![그래프](/image/그래프6.png)

- [방향 그래프 구현 코드](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EB%B0%A9%ED%96%A5%EA%B7%B8%EB%9E%98%ED%94%84.html)

- 방향 그래프 구현 (1)

  - Graph() 생성자 함수, addVertex() 메서드, addEdge() 메서드 구현

    ![그래프](/image/그래프7.png)

- 방향 그래프 구현 (2)

  - removeEdge() 메서드, removeVertex() 메서드 구현

    ![그래프](/image/그래프8.png)

- 방향 그래프 구현 (3)

  - sizeVertex() 메서드, sizeEdge() 메서드, print() 메서드 구현

    ![그래프](/image/그래프9.png)

- 딕셔너리 객체를 이용해서 인접리스트로 `무방향` 그래프를 구현해 볼 것이다.

- 무방향 그래프 구현 (1)

  - [무방향 그래프 코드 구현](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EB%AC%B4%EB%B0%A9%ED%96%A5%EA%B7%B8%EB%9E%98%ED%94%84.html)

  - 무방향 그래프는 방향 그래프의 addEdge() 메서드와 removeEdge() 메서드의 조금의 코드 수정만 한다면 양방향의 정점들의 연결성을 연결해 줄 수 있다.

    ![그래프](/image/그래프10.png)

## 5. 그래프의 탐색

- 일반적인 그래프의 탐색(순회) 방법은 두 가지가 있다.

- ### 5-1. `깊이 우선 탐색(DFS, Depth-First Search)`

  - 트리나 그래프 등에서 하나의 노드를 최대한 `깊게` 들어가면서 해를 찾는 탐색 기법이다.

  - 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것. 즉, 넓게 탐색하기 전에 깊에 탐색하는 것이다.

  - 예시)  
    미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.

  - `모든 노드를 방문` 하고자 하는 경우에 이 방법을 사용한다.

    - 깊이 우선 탐색이 너비 우선 탐색보다 좀 더 간단하다.

    - 단순 검색 속도 자체는 너비 우선 탐색에 비해서 느리다.

  - 장점

    - 인접한 후보 노드만 기억하면 되므로 적은 기억 공간 소요

    - 노드가 깊은 단계에 있을 경우 빠르게 정답 산출

  - 단점

    - 선택한 경로가 답이 아닐 경우 불필요한 탐색 가능

    - 최단 경로를 구할 시 찾은 해가 정답이 아닐 경우 발생

  - 깊이 우선 탐색의 특징

    - 자기 자신을 호출하는 `순환 알고리즘의 형태`를 가지고 있다.

    - 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.

    - 이 알고리즘을 구현할 때 가장 큰 차이점은 그래프 탐색의 경우 `어떤 노드를 방문했었는지 여부를 반드시 검사`해여 한다는 것이다. 만약 그렇지 않으면 무한루프에 빠질 위험이 있다.

      ![DFS](/image/DFS.png)

  - 깊이 우선 탐색의 구현 방법은 2가지가 있다.

    1. 재귀를 이용한 탐색

    - [재귀를 이용한 탐색 구현 코드 -DFS](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/DFS.html)

    - 방향 그래프 구현 + dfs() 메서드, \_dfsRecursiveVisit() 메서드 구현

      ![DFS](/image/DFS2.png)

    2. 스택을 이용한 탐색

       - [스택을 이용한 탐색 구현 코드 - DFS](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/DFS_2.html)

       - stack 구현 + 방향 그래프 구현 + dfs() 메서드, \_dfsLoopVisit() 메서드 구현

         ![DFS](/image/DFS3.png)

- ### 5-2. `너비 우선 탐색(BFS, Breadth-First Search)`

  - 트리나 그래프 등에서 `인접한 노드를 우선 방문`하면서 넓게 움직이며 해를 찾는 탐색 기법이다.

  - 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.

  - 층별 순회랑 동일한 플로우이다.

  - 즉, 깊게 탐색하기 전에 넓게 탐색하는 것이다.

  - 예시)  
    지구상에 존재하는 모든 친구 관계를 그래프로 표현한 후 "Ash" 와 "Vanessa" 사이에 존재하는 경로를 찾는 경우

    - 깊이 우선 탐색을 하면 모든 친구 관계를 다 살펴 봐야 할지도 모른다.

    - 하지만 넓이 우선 탐색을 하면 Ash와 가까운 관계부터 탐색 할 수 있다.

  - `두 노드 사이의 최단 경로` 혹은 `임의의 경로를 찾고 싶을 때` 이 방법을 사용한다.

  - 장점

    - 최단 경로 탐색에서 구한 해가 정답임을 보장한다.

  - 단점

    - 경로가 매우 길어질 경우, 탐색 범위가 증가하면서 DFS 보다 많은 기억공간이 필요하다.

  - 너비 우선 탐색의 특징

    - 직관적이지 않은 면이 있다.

      - BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.

    - BFS는 `재귀적으로 동작하지 않는다.`

    - 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 `어떤 노드를 방문했었는지 여부를 반드시 검사`해야 한다. 그렇지 않으면 무한루프에 빠질 위험이 있다.

    - BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료구조인 `큐`를 사용한다.

    - "Prim", "Dijkstra" 알고리즘과 유사하다.

      ![bfs](/image/bfs.png)

  - 너비 우선 탐색의 구현 방법

    1. 큐를 이용한 탐색

       - [큐를 이용한 탐색 구현 코드 - BFS](https://github.com/gang-min/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/BFS.html)

       - 큐 구현 + 방향 그래프 구현 + bfs() 메서드, \_bfsLoopVisit() 메서드 구현

         ![bfs](/image/bfs2.png)

       - 최단 경로, 비용 탐색을 위한 메서드도 추가로 구현

         - \_bfsShortestPath() 메서드

           ![bfs](/image/bfs3.png)

       - from 정점에서 to 정점으로 가는 최단 경로 출력하는 메서드 구현

         - \_from_to_path() 메서드, shortestPath() 메서드

           ![bfs](/image/bfs4.png)
